plugins {
    id 'base'
}

// Load build properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Load releases properties
def releasesProps = new Properties()
file('releases.properties').withInputStream { releasesProps.load(it) }

// Project properties
ext {
    bundleName = buildProps.getProperty('bundle.name')
    bundleRelease = buildProps.getProperty('bundle.release')
    bundleType = buildProps.getProperty('bundle.type')
    bundleFormat = buildProps.getProperty('bundle.format')
    
    // Determine build path - keep as File object like Bruno's ANT location property
    def buildPathStr = buildProps.getProperty('build.path') ?: System.getenv('BEARSAMPP_BUILD_PATH')
    buildPathFile = buildPathStr ? file(buildPathStr) : file('../bearsampp-build')
    
    // Derived paths
    rootDir = file('..')
    devPath = new File(rootDir, 'dev')
    
    // Bundle paths as File objects
    bundleTmpPath = new File(buildPathFile, 'tmp')
    bundleTmpPrepPath = new File(bundleTmpPath, 'prep')
}

// Helper function to generate hash files
def generateHashFiles(File file) {
    if (!file.exists()) {
        throw new GradleException("File not found for hashing: ${file}")
    }

    // Generate MD5
    def md5File = new File("${file.absolutePath}.md5")
    def md5Hash = calculateHash(file, 'MD5')
    md5File.text = "${md5Hash}  ${file.name}\n"
    println "  Created: ${md5File.name}"

    // Generate SHA1
    def sha1File = new File("${file.absolutePath}.sha1")
    def sha1Hash = calculateHash(file, 'SHA-1')
    sha1File.text = "${sha1Hash}  ${file.name}\n"
    println "  Created: ${sha1File.name}"

    // Generate SHA256
    def sha256File = new File("${file.absolutePath}.sha256")
    def sha256Hash = calculateHash(file, 'SHA-256')
    sha256File.text = "${sha256Hash}  ${file.name}\n"
    println "  Created: ${sha256File.name}"

    // Generate SHA512
    def sha512File = new File("${file.absolutePath}.sha512")
    def sha512Hash = calculateHash(file, 'SHA-512')
    sha512File.text = "${sha512Hash}  ${file.name}\n"
    println "  Created: ${sha512File.name}"
}

// Helper function to calculate hash
def calculateHash(File file, String algorithm) {
    def digest = java.security.MessageDigest.getInstance(algorithm)
    file.withInputStream { stream ->
        def buffer = new byte[8192]
        def bytesRead
        while ((bytesRead = stream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead)
        }
    }
    return digest.digest().collect { String.format('%02x', it) }.join('')
}

// Verify dev project exists
task verifyDevProject {
    doLast {
        def devDir = file(devPath)
        if (!devDir.exists()) {
            throw new GradleException("Project 'dev' not found in ${devPath}")
        }
        logger.lifecycle("Bearsampp dev found in ${devPath}")
    }
}

// Interactive version selection task
task selectVersion {
    doLast {
        println "\n=== Bearsampp Module Builder - ${bundleName} ==="
        println "Available versions:"
        println "=" * 60
        
        // Collect versions from releases.properties
        def releasesVersions = releasesProps.keySet() as Set
        
        // Collect versions from bin/ directory
        def binVersions = [] as Set
        def binDir = file('bin')
        if (binDir.exists() && binDir.isDirectory()) {
            binDir.listFiles().each { dir ->
                if (dir.isDirectory()) {
                    def dirName = dir.name
                    if (dirName.startsWith(bundleName)) {
                        def version = dirName.substring(bundleName.length())
                        binVersions.add(version)
                    }
                }
            }
        }
        
        // Collect versions from bin/archived/ directory
        def archivedVersions = [] as Set
        def archivedDir = file('bin/archived')
        if (archivedDir.exists() && archivedDir.isDirectory()) {
            archivedDir.listFiles().each { dir ->
                if (dir.isDirectory()) {
                    def dirName = dir.name
                    if (dirName.startsWith(bundleName)) {
                        def version = dirName.substring(bundleName.length())
                        archivedVersions.add(version)
                    }
                }
            }
        }
        
        // Combine all versions
        def allVersions = (releasesVersions + binVersions + archivedVersions) as Set
        
        // Sort versions numerically
        def versions = allVersions.sort { a, b ->
            def aParts = a.toString().split('\\.').collect { it.toInteger() }
            def bParts = b.toString().split('\\.').collect { it.toInteger() }
            for (int i = 0; i < Math.min(aParts.size(), bParts.size()); i++) {
                if (aParts[i] != bParts[i]) {
                    return aParts[i] <=> bParts[i]
                }
            }
            return aParts.size() <=> bParts.size()
        }
        
        versions.eachWithIndex { version, index ->
            def path = ""
            if (binVersions.contains(version)) {
                path = "[bin]"
            } else if (archivedVersions.contains(version)) {
                path = "[bin/archived]"
            } else if (releasesVersions.contains(version)) {
                path = "[releases]"
            }
            println "${index + 1}. ${version} ${path}"
        }
        
        // Check if version is specified via command line
        def specifiedVersion = null
        if (project.hasProperty('version')) {
            def versionProp = project.property('version')
            // Only use if it's not the default "unspecified" value
            if (versionProp != null && versionProp != 'unspecified' && versionProp.toString().trim() != '') {
                specifiedVersion = versionProp.toString()
            }
        }
        
        def selectedVersion
        
        if (specifiedVersion) {
            // Version specified via -Pversion=X.X.X
            selectedVersion = specifiedVersion
            println "\nUsing specified version: ${selectedVersion}"
        } else {
            // Always prompt for version selection
            println "\nEnter version number (or type version directly, or 'custom' for unlisted version): "
            
            def input
            def console = System.console()
            if (console != null) {
                input = console.readLine()?.trim()
            } else {
                // Fallback to System.in when console is not available
                def reader = new BufferedReader(new InputStreamReader(System.in))
                input = reader.readLine()?.trim()
            }
            
            if (!input) {
                throw new GradleException("No version selected")
            }
            
            if (input.isInteger()) {
                def index = input.toInteger() - 1
                if (index >= 0 && index < versions.size()) {
                    selectedVersion = versions[index]
                } else {
                    throw new GradleException("Invalid selection: ${input}. Please enter a number between 1 and ${versions.size()}")
                }
            } else if (input.equalsIgnoreCase('custom')) {
                println "Enter custom version: "
                def customInput
                if (console != null) {
                    customInput = console.readLine()?.trim()
                } else {
                    def reader = new BufferedReader(new InputStreamReader(System.in))
                    customInput = reader.readLine()?.trim()
                }
                if (!customInput) {
                    throw new GradleException("No version entered")
                }
                selectedVersion = customInput
            } else {
                selectedVersion = input
            }
        }
        
        project.ext.selectedVersion = selectedVersion
        println "\nSelected version: ${selectedVersion}"
        
        // Store for other tasks
        project.ext.bundleVersion = selectedVersion
        project.ext.bundleFolder = "${bundleName}${selectedVersion}"
        
        // Check if version exists in bin/ with actual mailpit.exe
        def binPath = file("bin/${bundleFolder}")
        def archivedPath = file("bin/archived/${bundleFolder}")
        
        if (binPath.exists() && file("${binPath}/mailpit.exe").exists()) {
            // Use local version from bin/ if mailpit.exe exists
            project.ext.bundlePath = "bin/${bundleFolder}"
            project.ext.useLocalVersion = true
            println "Using local version from: bin/${bundleFolder}"
        } else {
            // For archived or non-existent versions, download from remote
            // But use archived path for overlay if it exists
            if (archivedPath.exists()) {
                project.ext.bundlePath = "bin/archived/${bundleFolder}"
            } else {
                project.ext.bundlePath = "bin/${bundleFolder}"
            }
            project.ext.useLocalVersion = false
            println "Will download version from remote"
        }
    }
}

// Download and extract module
task downloadModule(dependsOn: selectVersion) {
    doLast {
        def version = project.ext.selectedVersion
        def bundlePath = project.ext.bundlePath
        def useLocalVersion = project.ext.useLocalVersion
        
        // If using local version, just set the extracted path
        if (useLocalVersion) {
            def localDir = file(bundlePath)
            def mailpitExe = new File(localDir, "mailpit.exe")
            
            if (!mailpitExe.exists()) {
                throw new GradleException("mailpit.exe not found in local path: ${bundlePath}")
            }
            
            println "Using local version, skipping download"
            project.ext.extractedPath = localDir.absolutePath
            return
        }
        
        // Otherwise, download from remote
        def downloadUrl = releasesProps.getProperty(version)
        
        if (!downloadUrl) {
            println "\nVersion ${version} not found in releases.properties"
            println "Checking modules-untouched repository..."
            
            // Construct URL from modules-untouched
            def untouchedUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/${bundleName}.properties"
            
            try {
                def untouchedProps = new Properties()
                new URL(untouchedUrl).withInputStream { stream ->
                    untouchedProps.load(stream)
                }
                
                downloadUrl = untouchedProps.getProperty(version)
                
                if (!downloadUrl) {
                    throw new GradleException("Version ${version} not found in modules-untouched repository either")
                }
                
                println "Found in modules-untouched: ${downloadUrl}"
            } catch (Exception e) {
                throw new GradleException("Failed to fetch from modules-untouched: ${e.message}")
            }
        }
        
        println "\nDownload URL: ${downloadUrl}"
        
        // Create temp directory
        def tempDir = new File(bundleTmpPath, "download")
        tempDir.mkdirs()
        
        // Extract version-specific download logic
        def fileName = downloadUrl.substring(downloadUrl.lastIndexOf('/') + 1)
        def downloadFile = new File(tempDir, fileName)
        
        println "Downloading to: ${downloadFile}"
        
        // Download file
        ant.get(src: downloadUrl, dest: downloadFile, verbose: true)
        
        // Extract archive
        def extractDir = new File(new File(bundleTmpPath, "extract"), bundleFolder)
        extractDir.mkdirs()
        
        println "Extracting to: ${extractDir}"
        
        if (fileName.endsWith('.7z')) {
            // Use 7z to extract
            def result = "7z x \"${downloadFile.absolutePath}\" -o\"${extractDir.absolutePath}\" -y".execute()
            result.waitFor()
            if (result.exitValue() != 0) {
                throw new GradleException("Failed to extract 7z archive: ${result.err.text}")
            }
        } else if (fileName.endsWith('.zip')) {
            ant.unzip(src: downloadFile, dest: extractDir)
        }
        
        // Find the mailpit.exe in extracted content
        def mailpitExe = fileTree(extractDir).matching {
            include '**/mailpit.exe'
        }.files.first()
        
        if (!mailpitExe) {
            throw new GradleException("mailpit.exe not found in extracted archive")
        }
        
        println "Found mailpit.exe at: ${mailpitExe}"
        
        // Store extraction path for next task
        project.ext.extractedPath = mailpitExe.parentFile.absolutePath
    }
}

// Prepare bundle
task prepareBundle(dependsOn: downloadModule) {
    doLast {
        def bundleFolder = project.ext.bundleFolder
        def bundlePath = project.ext.bundlePath
        def extractedPath = project.ext.extractedPath
        
        // Verify mailpit.exe exists
        def mailpitExe = new File(extractedPath, "mailpit.exe")
        if (!mailpitExe.exists()) {
            throw new GradleException("mailpit.exe not found at ${mailpitExe}")
        }
        
        // Create prep directory
        def prepDir = new File(bundleTmpPrepPath, bundleFolder)
        prepDir.deleteDir()
        prepDir.mkdirs()
        
        println "Preparing bundle in: ${prepDir}"
        
        // Copy from extracted source (excluding doc)
        copy {
            from extractedPath
            into prepDir
            exclude 'doc/**'
        }
        
        // Copy from bundle path (overlay with module-specific files)
        def bundleDir = file(bundlePath)
        if (bundleDir.exists()) {
            copy {
                from bundleDir
                into prepDir
            }
        } else {
            println "Warning: Bundle path ${bundlePath} does not exist, skipping overlay"
        }
        
        println "Bundle prepared successfully"
    }
}

// Create release archive
task createRelease(dependsOn: prepareBundle) {
    doLast {
        def bundleFolder = project.ext.bundleFolder
        def prepDir = new File(bundleTmpPrepPath, bundleFolder)
        
        // Create release directory: buildPath/{bundleType}/{bundleName}/{bundleRelease}
        def releaseDir = new File(new File(new File(buildPathFile, bundleType), bundleName), bundleRelease)
        releaseDir.mkdirs()
        
        def archiveName = "bearsampp-${bundleName}-${project.ext.selectedVersion}-${bundleRelease}.${bundleFormat}"
        def archiveFile = new File(releaseDir, archiveName)
        
        println "Creating release archive: ${archiveFile}"
        
        if (bundleFormat == '7z') {
            def result = "7z a -t7z -mx9 \"${archiveFile.absolutePath}\" \"${prepDir.absolutePath}\\*\"".execute()
            result.waitFor()
            if (result.exitValue() != 0) {
                throw new GradleException("Failed to create 7z archive: ${result.err.text}")
            }
        } else if (bundleFormat == 'zip') {
            ant.zip(destfile: archiveFile, basedir: prepDir)
        }
        
        // Generate checksums
        println "Generating checksums..."
        generateHashFiles(archiveFile)
        
        println "\n" + "=" * 60
        println "Release created successfully!"
        println "Archive: ${archiveFile}"
        println "Size: ${String.format('%.2f MB', archiveFile.length() / 1024 / 1024)}"
        println "Checksums: MD5, SHA1, SHA256, SHA512"
        println "=" * 60
    }
}

// Main build task
task releaseBuild {
    dependsOn verifyDevProject, createRelease
    group = 'build'
    description = 'Build a release bundle for the selected version'
}

// Alias for Bruno's method compatibility
task release {
    dependsOn releaseBuild
    group = 'build'
    description = 'Alias for releaseBuild (Bruno\'s method compatibility)'
}

// Clean task
task cleanBuild(type: Delete) {
    delete "${bundleTmpPath}"
    group = 'build'
    description = 'Clean temporary build files'
}

// Default task
defaultTasks 'releaseBuild'
